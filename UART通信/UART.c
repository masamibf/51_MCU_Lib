
#include"UART.h"

bit flagEnd = 0;                       //帧接收完成标志 接收完一帧新数据
bit flagTxd = 0;                       //单字节发送完成标志

uchar cntRxd = 0;                      //接收字节计数器
uchar pdata bufRxd[64] ;               //接收字节缓冲区
/*****************************************配置串口波特率函数********************************************************/
/*                                           baud 为波特率                                                         */
/*******************************************************************************************************************/
void ConfigUART(uint baud)
{
	SCON = 0x50;                         //配置串口为模式1
	TMOD &= 0x0F;
	TMOD |= 0x20;                        //T1工作为模式2
	TH1 = 256-(12000000/12/32)/baud;     //重载初值     TL1溢出后TH1中的值自动装载到TL1中
	TL1 = TH1;
	ET1 = 0;                             //关闭T1中断
	ES = 1;                              //使能串口中断
	TR1 = 1;                             //使能T1
}

/**********************************************串口发送函数*********************************************************/
/*                                   buf为待发送数据的指针     len为指定发送长度                                   */          
/*******************************************************************************************************************/
void UART_Write(uchar *buf,uchar len)
{
	while(len--)                         //循环发送所有字节
	{
		flagTxd=0;                         //清零发送标志位
		SBUF=*buf++;                       //发送一个字节数据
		while(!flagTxd);                   //待该字节发送完成
	}
}

/*********************************************串口数据读取函数******************************************************/
/*                      buf为接收指针         len为指定读取长度   返回值 实际读取到的长度                          */
/*******************************************************************************************************************/
signed char UART_Read(uchar *buf,uchar len)
{
	uchar i;
	if(len>cntRxd)                       //若指定长度大于实际接收数据长度  读取长度设置为实际长度
	{
		len=cntRxd;
	}
	for(i=0;i<64;i++)
	{
		*buf++=bufRxd[i];                  //拷贝接收到的数据到接收指针上
	}
	cntRxd=0;                            //接收计数 清零
	return len;                          //返回 读取长度 的值
}

/*********************************************串口接收监控函数******************************************************/
/*                    由空闲时间判定 帧 结束  在定时器中断里调用 ms 毫秒级别                                       */
/*******************************************************************************************************************/
void UART_RX_Monitor(uchar ms)
{
	static uchar cntbkp=0;
	static uchar freetmr=0;
	if(cntRxd>0)                         //当接收计数器大于0时 监测总线空闲时间
	{
		if(cntbkp!=cntRxd)                 //接收计数器改变 即刚接收到数据时 清零 空闲计时
		{
			cntbkp=cntRxd;
			freetmr=0;
		}
		else                               //接收计数器未改变 即总线空闲时 累积空闲时间
		{
			if(freetmr<30)                   //空闲时间小于30ms时 空闲时间持续累加
			{
				freetmr+=ms;
				if(freetmr>=30)                //空闲时间大于30ms 设置帧接收完成标志
				{
					flagEnd=1;
				}
			}
		}
	}
	else
		cntbkp=0;
}

/************************************************串口驱动函数*******************************************************/
/*                                 监测数据帧的接收 调用功能函数 在主循环中调用                                    */
/*******************************************************************************************************************/
void UART_Driver()
{
	uchar len=0;
	uchar pdata buf[40];
	if(flagEnd)
	{
		flagEnd=0;                         //有命令到达时读取处理该命令
		len=UART_Read(buf,sizeof(buf));    //将接收到的命令读取到缓冲区
		UART_Action(buf,len);              //传送数据帧 调用动作执行函数
	}
}

/******************************************串口中断服务函数*********************************************************/
/*                                                                                                                 */
/*******************************************************************************************************************/
void InterruptUART() interrupt 4
{
	if(RI)                               //接收到新字节
	{
		RI=0;                              //清零中断标志位
		if(cntRxd<sizeof(bufRxd))          //接收缓冲区尚未用完时
		{
			bufRxd[cntRxd++]=SBUF;           //保存接收字节 并且递增计数器
		}
	}
	if(TI)                               //字节发送完毕
	{
		TI=0;                              //清零
		flagTxd=1;                         //设置字节发送完毕标志
	}
}