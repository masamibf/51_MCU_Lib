#include "infrared.h"
#include "key.h"

sbit INPUT = P3^2;                                    //定义红外接收引脚


bit irflag = 0;                        //红外接收标志位 收到一帧正确数据后置1
uchar codebuf[4];                      //红外代码接收缓冲区

/***********************************************************************/
/*                         红外键码表                                  */
/***********************************************************************/
const uchar code IrCodeMap[][2] = {
	  {0x45,0x00}, {0x46,0x00}, {0x47,0x1B}, //开关->无  Mode->无   静音->ESC
    {0x44,0x00}, {0x40,0x25}, {0x43,0x27}, //播放->无  后退->向左 前进->向右
    {0x07,0x00}, {0x15,0x28}, {0x09,0x26}, // EQ->无   减号->向下 加号->向上
    {0x16,0x30}, {0x19,0x1B}, {0x0D,0x0D}, //'0'->'0'  箭头->ESC  U/SD->回车
    {0x0C,0x31}, {0x18,0x32}, {0x5E,0x33}, //'1'->'1'  '2'->'2'   '3'->'3'
    {0x08,0x34}, {0x1C,0x35}, {0x5A,0x36}, //'4'->'4'  '5'->'5'   '6'->'6'
    {0x42,0x37}, {0x52,0x38}, {0x4A,0x39}, //'7'->'7'  '6'->'8'   '9'->'9'
};

/***********************************************************************/
/*                          红外驱动函数                               */
/***********************************************************************/
void InfraredDriver()
{
	uchar i;
	
	if(irflag)
	{
		irflag = 0;
		for(i = 0;i < sizeof(IrCodeMap)/sizeof(IrCodeMap[0]);i++)
		{
			if(codebuf[2] == IrCodeMap[i][0])
			{
				KeyDown(IrCodeMap[i][1]);
				break;
			}
		}
	}
}

/***********************************************************************/
/*                          红外接收初始化函数                         */
/***********************************************************************/
void InitInfrared()
{
	INPUT = 1;
	TMOD &= 0x0F;                       //清零T1控制位
	TMOD |= 0x10;                       //配置T1为模式1
	TR1  =  0;                          //禁止T1计数
	ET1  =  0;                          //禁止T1中断
	IT0  =  1;                          //设置INT0为负边沿触发
	EX0  =  1;                          //使能外部中断0
}

/***********************************************************************/
/*                        获取当前高电平持续时间                       */
/***********************************************************************/
uint GetHighTime()
{
	TH1 = 0;                            //清零T1计数值
	TL1 = 0;
	TR1 = 1;                            //开启T1计数
	while(INPUT)                        //红外输入引脚为1时循环等待 变为0时结束循环
	{ 
		if(TH1>=0x40)                      //当T1计数值大于0x40 即低电平持续时间超过约18ms时强制退出循环
			break;                          //避免信号异常时 程序假死在这里
	}
	TR1 = 0;                            //停止T1计数
	return (TH1*256+TL1);               //T1计数值合成为16bit整型数 并返回
}


/***********************************************************************/
/*                        获取当前低电平持续时间                       */
/***********************************************************************/
uint GetLowTime()
{
	TH1 = 0;
  TL1 = 0;
	TR1 = 1;                            //开启T1计数
	while(!INPUT)                       //红外输入引脚为0时循环等待 变为1时结束循环
	{ 
		if(TH1>=0x40)                      //当T1计数值大于0x40 即低电平持续时间超过约18ms时强制退出循环
			break;                          //避免信号异常时 程序假死在这里
	}
	TR1 = 0;                            //停止T1计数
	return (TH1*256+TL1);               //T1计数值合成为16bit整型数 并返回
}

/***********************************************************************/
/*                   INT0中断函数 执行红外接收及解码                   */
/***********************************************************************/
void InterruputINT0() interrupt 0
{
	uchar i,j;
	uint time;
	uchar byte;
	
//*************接收并判定引导码的9ms的低电平**************//
	time = GetLowTime();                
//if((time<7833)||(time>8755))        //时间判定范围为8.5ms~9.5ms 超过此范围说明为误码 退出(11.0592MHz晶振)
  if((time<8500)||(time>9500))        //时间判定范围为8.5ms~9.5ms 超过此范围说明为误码 退出(12.0000MHz晶振)
	{
		IE0 = 0;                          //退出前清零INT0中断标志位
		return;
	}
	
//*************接收并判定引导码的4.5ms的高电平***********//	
	time = GetHighTime();             
//if((time<3686)||(time>4608))        //时间判定范围为4.0ms~5.0ms 超过此范围说明为误码 退出(11.0592MHz晶振)
  if((time<4000)||(time>5000))        //时间判定范围为4.0ms~5.0ms 超过此范围说明为误码 退出(12.0000MHz晶振)
	{
		IE0 = 0;
		return;
	}
	
//*************接收并判定后续的4个字节数据***************//
	for(i=0;i<4;i++)                    
	{
		for(j=0;j<8;j++)                  //循环接收并判定每个字节的8个bit
		{
			time = GetLowTime();            //接收并判定每个bit的560us低电平
		//if((time<313)||(time>718))      //时间判定范围为340us~780us 超过此范围说明为误码 退出(11.0592MHz晶振)
		  if((time<340)||(time>780))      //时间判定范围为340us~780us 超过此范围说明为误码 退出(12.0000MHz晶振)
			{
				IE0 = 0;
				return;
			}
			
			time = GetHighTime();
		//if((time>313)&&(time<718))             //时间判定范围为340us~780us 在此范围说明该bit值0(11.0592MHz晶振)
		  if((time>340)&&(time<780))             //时间判定范围为340us~780us 在此范围说明该bit值0(12.0000MHz晶振)
			{
				byte>>=1;                            //低位在先 数据右移 高位为0
			}
	  //else if((time>1345)&&(time<1751))      //时间判定范围为1460us~1900us 在此范围说明该bit值1(11.0592MHz晶振)
		  else if((time>1460)&&(time<1900))      //时间判定范围为1460us~1900us 在此范围说明该bit值1(12.0000MHz晶振)
			{
				byte>>=1;
				byte|=0x80;                          //最高位置1
			}
			else                                   //不在以上范围内说明为误码 退出
			{
				IE0 = 0;
				return;
			}
		}
		codebuf[i] = byte;
	}
	irflag = 1;                              //接收完成后标志置1
	IE0 = 0;
}